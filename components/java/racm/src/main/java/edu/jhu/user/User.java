/**
This code was originally automatically generated from the UML model in
https://github.com/sciserver/resource-management/blob/master/vo-urp/RACM_v1.xml
using the VO-URP tool, https://github.com/sciserver/vo-urp. 
It is now included in the code-base and will no longer be 
generated automatically. You can edit this file, but be aware
of its origins when interpreting it.
**/

package edu.jhu.user;

import java.util.Date;

import java.util.Map;
import org.ivoa.dm.model.MetadataElement;
import org.ivoa.dm.model.IMetadataObjectContainer;
import org.ivoa.dm.model.Reference;
import org.ivoa.dm.model.TransientObjectManager;
import org.ivoa.dm.model.MetadataObject;
import org.ivoa.dm.model.MetadataRootEntityObject;
import static edu.jhu.ModelVersion.LAST_MODIFICATION_DATE;

/**
 * UML Object User :
 *
 * 
 * TODO : Missing description : please, update your UML model asap.
 *
 * 
 * @author generated by VO-URP tools VO-URP Home
 * @author Laurent Bourges (voparis) / Gerard Lemson (mpe)
 */

@javax.persistence.Entity @javax.persistence.Table(name = "t_User")

@javax.persistence.Inheritance(strategy = javax.persistence.InheritanceType.JOINED) @javax.persistence.DiscriminatorColumn(name = "DTYPE", discriminatorType = javax.persistence.DiscriminatorType.STRING, length = 32)

@javax.persistence.DiscriminatorValue("User")

@javax.persistence.NamedQueries({
        @javax.persistence.NamedQuery(name = "User.findById", query = "SELECT o FROM User o WHERE o.id = :id"),
        @javax.persistence.NamedQuery(name = "User.findByPublisherDID", query = "SELECT o FROM User o WHERE o.identity.publisherDID = :publisherDID")

})

public class User extends SciserverEntity {

    /** serial uid = last modification date of the UML model. */
    private static final long serialVersionUID = LAST_MODIFICATION_DATE;

    /**
     * Attribute userId : Identifier provided by the "real" user management tool, i.e. the one that controls
     * users/password, possibly single-sign-on etc. Currently this is keystone ( Multiplicity : 1 , MaxLength : 128 )
     */

    @javax.persistence.Basic(optional = false) @javax.persistence.Column(name = "userId", nullable = false, length = 128)

    private String userId;

    /**
     * Attribute username :
     * 
     * TODO : Missing description : please, update your UML model asap.
     * 
     * ( Multiplicity : 1 )
     */

    @javax.persistence.Basic(optional = false) @javax.persistence.Column(name = "username", nullable = false)

    private String username;

    /**
     * Attribute contactEmail :
     * 
     * TODO : Missing description : please, update your UML model asap.
     * 
     * ( Multiplicity : 0..1 )
     */

    @javax.persistence.Basic(optional = true) @javax.persistence.Column(name = "contactEmail", nullable = true)

    private String contactEmail;

    /**
     * Attribute trustId :
     * 
     * TODO : Missing description : please, update your UML model asap.
     * 
     * ( Multiplicity : 0..1 )
     */

    @javax.persistence.Basic(optional = true) @javax.persistence.Column(name = "trustId", nullable = true)

    private String trustId;

    /**
     * Attribute visibility :
     * 
     * TODO : Missing description : please, update your UML model asap.
     * 
     * ( Multiplicity : 1 )
     */

    @javax.persistence.Basic(optional = false) @javax.persistence.Enumerated(javax.persistence.EnumType.STRING) @javax.persistence.Column(name = "visibility", nullable = false)

    private UserVisibility visibility;

    /**
     * Attribute preferences : JSON string modified by dashboard UI ( Multiplicity : 0..1 , MaxLength : -1 )
     */

    @javax.persistence.Basic(fetch = javax.persistence.FetchType.EAGER, optional = true) @javax.persistence.Lob @javax.persistence.Column(name = "preferences", nullable = true)

    private String preferences;

    /**
     * Reference party :
     * 
     * TODO : Missing description : please, update your UML model asap.
     * 
     * ( Multiplicity : 0..1 )
     */

    @javax.persistence.ManyToOne(optional = true, fetch = javax.persistence.FetchType.LAZY, cascade = {
            javax.persistence.CascadeType.PERSIST, javax.persistence.CascadeType.MERGE,
            javax.persistence.CascadeType.REFRESH }) @javax.persistence.JoinColumn(name = "partyId", referencedColumnName = "id", nullable = true)

    private Party party = null;
    /**
     * "lazy" version of the party reference. Used by XML (un)marshallers to resolve possibly inderectly referenced
     * resource Party.
     */

    @javax.persistence.Transient

    protected Reference p_party = null;

    /**
     * Creates a new User.
     */
    protected User() {
        super();
    }

    /**
     * Creates a new User for the given Container Entity.
     *
     * The Parent Container CAN NOT BE NULL
     *
     * @param pContainer the parent container CAN NOT BE NULL
     */
    public User(final TransientObjectManager pContainer) {
        super(pContainer);
    }

    /**
     * Returns userId Attribute
     * 
     * @return userId Attribute
     */
    public String getUserId() {
        return this.userId;
    }

    /**
     * Defines userId Attribute
     * 
     * @param pUserId value to set
     */
    public void setUserId(final String pUserId) {
        this.userId = pUserId;
    }

    /**
     * Returns username Attribute
     * 
     * @return username Attribute
     */
    public String getUsername() {
        return this.username;
    }

    /**
     * Defines username Attribute
     * 
     * @param pUsername value to set
     */
    public void setUsername(final String pUsername) {
        this.username = pUsername;
    }

    /**
     * Returns contactEmail Attribute
     * 
     * @return contactEmail Attribute
     */
    public String getContactEmail() {
        return this.contactEmail;
    }

    /**
     * Defines contactEmail Attribute
     * 
     * @param pContactEmail value to set
     */
    public void setContactEmail(final String pContactEmail) {
        this.contactEmail = pContactEmail;
    }

    /**
     * Returns trustId Attribute
     * 
     * @return trustId Attribute
     */
    public String getTrustId() {
        return this.trustId;
    }

    /**
     * Defines trustId Attribute
     * 
     * @param pTrustId value to set
     */
    public void setTrustId(final String pTrustId) {
        this.trustId = pTrustId;
    }

    /**
     * Returns visibility Attribute
     * 
     * @return visibility Attribute
     */
    public UserVisibility getVisibility() {
        return this.visibility;
    }

    /**
     * Defines visibility Attribute
     * 
     * @param pVisibility value to set
     */
    public void setVisibility(final UserVisibility pVisibility) {
        this.visibility = pVisibility;
    }

    /**
     * Returns preferences Attribute
     * 
     * @return preferences Attribute
     */
    public String getPreferences() {
        return this.preferences;
    }

    /**
     * Defines preferences Attribute
     * 
     * @param pPreferences value to set
     */
    public void setPreferences(final String pPreferences) {
        this.preferences = pPreferences;
    }

    /**
     * Returns party Reference If the party variable is null but its "lazy" version p_party is not, that lazy reference
     * will be resolved to the actual object.
     * 
     * @return party Reference
     */
    public Party getParty() {

        if (this.party == null && this.p_party != null) {
            this.party = (Party) resolve(this.p_party, Party.class);
        }
        return this.party;

    }

    /**
     * Defines party Reference
     * 
     * @param pParty reference to set
     */
    public void setParty(final Party pParty) {

        this.party = pParty;

    }

    /**
     * Returns equals from id attribute here. Child classes can override this method to allow deep equals with
     * attributes / references / collections
     *
     * @param object the reference object with which to compare.
     * @param isDeep true means to call hashCode(sb, true) for all attributes / references / collections which are
     * MetadataElement implementations
     *
     * @return <code>true</code> if this object is the same as the obj argument; <code>false</code> otherwise.
     */
    @Override
    public boolean equals(final Object object, final boolean isDeep) {
        /* identity, nullable, class and identifiers checks */
        if (!(super.equals(object, isDeep))) {
            return false;
        }

        /* do check values (attributes / references / collections) */

        if (isDeep) {

            final User other = (User) object;

            if (!areEquals(this.userId, other.userId)) {
                return false;
            }

            if (!areEquals(this.username, other.username)) {
                return false;
            }

            if (!areEquals(this.contactEmail, other.contactEmail)) {
                return false;
            }

            if (!areEquals(this.trustId, other.trustId)) {
                return false;
            }

            if (!areEquals(this.visibility, other.visibility)) {
                return false;
            }

            if (!areEquals(this.preferences, other.preferences)) {
                return false;
            }

        }

        return true;
    }

    /**
     * Returns the property value given the property name. Can be any property (internal, attribute, reference,
     * collection) and all type must be supported (dataType, objectType, enumeration)
     *
     * @param propertyName name of the property (like in UML model)
     *
     * @return property value or null if unknown or not defined
     */
    @Override
    public Object getProperty(final String propertyName) {
        // first : checks if propertyName is null or empty :
        if (propertyName == null) {
            return null;
        }
        // second : search in parent classes (maybe null) :
        Object res = super.getProperty(propertyName);

        if ("userId".equals(propertyName)) {
            return getUserId();
        }

        if ("username".equals(propertyName)) {
            return getUsername();
        }

        if ("contactEmail".equals(propertyName)) {
            return getContactEmail();
        }

        if ("trustId".equals(propertyName)) {
            return getTrustId();
        }

        if ("visibility".equals(propertyName)) {
            return getVisibility();
        }

        if ("preferences".equals(propertyName)) {
            return getPreferences();
        }

        if ("party".equals(propertyName)) {
            return getParty();
        }

        return res;
    }

    /**
     * Sets the property value to the given property name. Can be any property (internal, attribute, reference,
     * collection) and all type must be supported (dataType, objectType, enumeration)
     *
     * @param propertyName name of the property (like in UML model)
     *
     * @param pValue to be set
     * 
     * @return true if property has been set
     */
    @Override
    public boolean setProperty(final String propertyName, final Object pValue) {
        // first : checks if propertyName is null or empty :
        if (propertyName == null) {
            return false;
        }
        // second : search in parent classes (maybe null) :
        boolean res = super.setProperty(propertyName, pValue);

        if (!res) {

            if ("userId".equals(propertyName)) {
                setUserId((String) pValue);
                return true;
            }

            if ("username".equals(propertyName)) {
                setUsername((String) pValue);
                return true;
            }

            if ("contactEmail".equals(propertyName)) {
                setContactEmail((String) pValue);
                return true;
            }

            if ("trustId".equals(propertyName)) {
                setTrustId((String) pValue);
                return true;
            }

            if ("visibility".equals(propertyName)) {
                setVisibility((UserVisibility) pValue);
                return true;
            }

            if ("preferences".equals(propertyName)) {
                setPreferences((String) pValue);
                return true;
            }

            if ("party".equals(propertyName)) {
                setParty((Party) pValue);
                return true;
            }

        }

        return res;
    }

    /**
     * Sets all Reference fields to their appropriate value.<br/>
     */
    @Override
    protected void prepareReferencesForMarshalling() {
        super.prepareReferencesForMarshalling();

        if (getParty() != null) {
            this.p_party = getParty().asReference();
            if (getStateFor(getParty()).isToBeMarshalled()) {
                getParty().setXmlId();
            }
        }

    }

    /**
     * Resets all Reference fields to null.<br/>
     */
    @Override
    protected void resetReferencesAfterMarshalling() {
        super.prepareReferencesForMarshalling();

        this.p_party = null;

    }

    /**
     * Puts the string representation in the given string buffer : <br>
     * "Type =[class name @ hashcode] : { field name = field value , ...}"
     *
     * @param sb given string buffer to fill
     * @param isDeep true means to call deepToString(sb, true, ids) for all attributes / references / collections which
     * are MetadataElement implementations
     * @param ids identity map to avoid cyclic loops
     *
     * @return stringbuffer the given string buffer filled with the string representation
     */
    @Override
    protected StringBuilder deepToString(final StringBuilder sb, final boolean isDeep,
            final Map<MetadataElement, Object> ids) {

        super.deepToString(sb, isDeep, ids);

        sb.append("\n[ User");
        sb.append("={");

        sb.append("userId=");
        if (getUserId() != null) {
            MetadataElement.deepToString(sb, isDeep, ids, getUserId());
        }
        sb.append(", ");
        sb.append("username=");
        if (getUsername() != null) {
            MetadataElement.deepToString(sb, isDeep, ids, getUsername());
        }
        sb.append(", ");
        sb.append("contactEmail=");
        if (getContactEmail() != null) {
            MetadataElement.deepToString(sb, isDeep, ids, getContactEmail());
        }
        sb.append(", ");
        sb.append("trustId=");
        if (getTrustId() != null) {
            MetadataElement.deepToString(sb, isDeep, ids, getTrustId());
        }
        sb.append(", ");
        sb.append("visibility=");
        if (getVisibility() != null) {
            MetadataElement.deepToString(sb, isDeep, ids, getVisibility());
        }
        sb.append(", ");
        sb.append("preferences=");
        if (getPreferences() != null) {
            MetadataElement.deepToString(sb, isDeep, ids, getPreferences());
        }
        sb.append(", ");
        sb.append("party.id=");
        if (getParty() != null) {
            getParty().getId();
        }

        return sb.append("} ]");

    }

    public boolean isValid() {
        if (!super.isValid())
            return false;
        boolean isOk = true;
        isOk = isOk && userId != null;
        isOk = isOk && username != null;
        isOk = isOk && visibility != null;
        return isOk;
    }

    public String validationErrors() {
        StringBuffer sb = new StringBuffer(super.validationErrors());

        if (userId == null)
            sb.append("- atribute 'userId' cannot be null\n");

        if (username == null)
            sb.append("- atribute 'username' cannot be null\n");

        if (visibility == null)
            sb.append("- atribute 'visibility' cannot be null\n");

        return sb.toString();
    }

}
