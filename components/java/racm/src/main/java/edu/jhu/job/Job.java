/**
This code was originally automatically generated from the UML model in
https://github.com/sciserver/resource-management/blob/master/vo-urp/RACM_v1.xml
using the VO-URP tool, https://github.com/sciserver/vo-urp. 
It is now included in the code-base and will no longer be 
generated automatically. You can edit this file, but be aware
of its origins when interpreting it.
**/

package edu.jhu.job;

import java.util.Date;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import org.ivoa.dm.model.MetadataElement;
import org.ivoa.dm.model.IMetadataObjectContainer;
import org.ivoa.dm.model.Reference;
import org.ivoa.dm.model.TransientObjectManager;
import org.ivoa.dm.model.MetadataObject;
import org.ivoa.dm.model.MetadataRootEntityObject;
import edu.jhu.user.User;

import static edu.jhu.ModelVersion.LAST_MODIFICATION_DATE;

/**
 * UML Object Job :
 *
 * 
 * TODO : Missing description : please, update your UML model asap.
 *
 * 
 * @author generated by VO-URP tools VO-URP Home
 * @author Laurent Bourges (voparis) / Gerard Lemson (mpe)
 */

@javax.persistence.Entity @javax.persistence.Table(name = "t_Job")

@javax.persistence.Inheritance(strategy = javax.persistence.InheritanceType.JOINED) @javax.persistence.DiscriminatorColumn(name = "DTYPE", discriminatorType = javax.persistence.DiscriminatorType.STRING, length = 32)

@javax.persistence.NamedQueries({
        @javax.persistence.NamedQuery(name = "Job.findById", query = "SELECT o FROM Job o WHERE o.id = :id"),
        @javax.persistence.NamedQuery(name = "Job.findByPublisherDID", query = "SELECT o FROM Job o WHERE o.identity.publisherDID = :publisherDID")

})

public abstract class Job extends MetadataRootEntityObject {

    /** serial uid = last modification date of the UML model. */
    private static final long serialVersionUID = LAST_MODIFICATION_DATE;

    /** classType gives the discriminator value stored in the database for an inheritance hierarchy */
    @javax.persistence.Column(name = "DTYPE", insertable = false, updatable = false, nullable = false)
    protected String classType;

    /** jpaVersion gives the current version number for that entity (used by pessimistic / optimistic locking in JPA) */
    @javax.persistence.Version() @javax.persistence.Column(name = "OPTLOCK")
    protected int jpaVersion;

    /**
     * Attribute submitTime :
     * 
     * TODO : Missing description : please, update your UML model asap.
     * 
     * ( Multiplicity : 1 )
     */

    @javax.persistence.Basic(optional = false) @javax.persistence.Temporal(javax.persistence.TemporalType.TIMESTAMP) @javax.persistence.Column(name = "submitTime", nullable = false)

    private Date submitTime;

    /**
     * Attribute expectedTime :
     * 
     * TODO : Missing description : please, update your UML model asap.
     * 
     * ( Multiplicity : 0..1 )
     */

    @javax.persistence.Basic(optional = true) @javax.persistence.Column(name = "expectedTime", nullable = true)

    private String expectedTime;

    /**
     * Attribute status :
     * 
     * TODO : Missing description : please, update your UML model asap.
     * 
     * ( Multiplicity : 1 , MaxLength : 4 )
     */

    @javax.persistence.Basic(optional = false) @javax.persistence.Column(name = "status", nullable = false, length = 4)

    private Integer status;

    /**
     * Attribute excutorDID :
     * 
     * TODO : Missing description : please, update your UML model asap.
     * 
     * ( Multiplicity : 0..1 )
     */

    @javax.persistence.Basic(optional = true) @javax.persistence.Column(name = "excutorDID", nullable = true)

    private String excutorDID;

    /**
     * Attribute submitterDID :
     * 
     * TODO : Missing description : please, update your UML model asap.
     * 
     * ( Multiplicity : 0..1 )
     */

    @javax.persistence.Basic(optional = true) @javax.persistence.Column(name = "submitterDID", nullable = true)

    private String submitterDID;

    /**
     * Attribute startedTime :
     * 
     * TODO : Missing description : please, update your UML model asap.
     * 
     * ( Multiplicity : 0..1 )
     */

    @javax.persistence.Basic(optional = true) @javax.persistence.Temporal(javax.persistence.TemporalType.TIMESTAMP) @javax.persistence.Column(name = "startedTime", nullable = true)

    private Date startedTime;

    /**
     * Attribute finishedTime :
     * 
     * TODO : Missing description : please, update your UML model asap.
     * 
     * ( Multiplicity : 0..1 )
     */

    @javax.persistence.Basic(optional = true) @javax.persistence.Temporal(javax.persistence.TemporalType.TIMESTAMP) @javax.persistence.Column(name = "finishedTime", nullable = true)

    private Date finishedTime;

    /**
     * Attribute duration : Duration in seconds of the job execution. Not necessarily the same as
     * finishedTime-startedTime. ( Multiplicity : 0..1 )
     */

    @javax.persistence.Basic(optional = true) @javax.persistence.Column(name = "duration", nullable = true)

    private Double duration;

    /**
     * Attribute resultsFolderURI :
     * 
     * TODO : Missing description : please, update your UML model asap.
     * 
     * ( Multiplicity : 0..1 )
     */

    @javax.persistence.Basic(optional = true) @javax.persistence.Column(name = "resultsFolderURI", nullable = true)

    private String resultsFolderURI;

    /**
     * Attribute timeout : Job timeout in seconds ( Multiplicity : 0..1 )
     */

    @javax.persistence.Basic(optional = true) @javax.persistence.Column(name = "timeout", nullable = true)

    private Long timeout;

    /**
     * Collection message :
     * 
     * TODO : Missing description : please, update your UML model asap.
     * 
     * ( Multiplicity : 0..* )
     */

    @javax.persistence.OneToMany(cascade = javax.persistence.CascadeType.ALL, fetch = javax.persistence.FetchType.LAZY, mappedBy = "container", orphanRemoval = true)

    private List<JobMessage> message = null;

    /**
     * Collection userVolume :
     * 
     * TODO : Missing description : please, update your UML model asap.
     * 
     * ( Multiplicity : 0..* )
     */

    @javax.persistence.OneToMany(cascade = javax.persistence.CascadeType.ALL, fetch = javax.persistence.FetchType.LAZY, mappedBy = "container", orphanRemoval = true)

    private List<RequiredUserVolume> userVolume = null;

    /**
     * Reference runBy :
     * 
     * TODO : Missing description : please, update your UML model asap.
     * 
     * ( Multiplicity : 0..1 )
     */

    @javax.persistence.ManyToOne(optional = true, fetch = javax.persistence.FetchType.LAZY, cascade = {
            javax.persistence.CascadeType.PERSIST, javax.persistence.CascadeType.MERGE,
            javax.persistence.CascadeType.REFRESH }) @javax.persistence.JoinColumn(name = "runById", referencedColumnName = "id", nullable = true)

    private COMPM runBy = null;
    /**
     * "lazy" version of the runBy reference. Used by XML (un)marshallers to resolve possibly inderectly referenced
     * resource COMPM.
     */

    @javax.persistence.Transient

    protected Reference p_runBy = null;

    /**
     * Reference computeDomain :
     * 
     * TODO : Missing description : please, update your UML model asap.
     * 
     * ( Multiplicity : 1 )
     */

    @javax.persistence.ManyToOne(optional = false, fetch = javax.persistence.FetchType.LAZY, cascade = {
            javax.persistence.CascadeType.PERSIST, javax.persistence.CascadeType.MERGE,
            javax.persistence.CascadeType.REFRESH }) @javax.persistence.JoinColumn(name = "computeDomainId", referencedColumnName = "id", nullable = false)

    private ComputeDomain computeDomain = null;
    /**
     * "lazy" version of the computeDomain reference. Used by XML (un)marshallers to resolve possibly inderectly
     * referenced resource ComputeDomain.
     */

    @javax.persistence.Transient

    protected Reference p_computeDomain = null;

    /**
     * Reference submitter :
     * 
     * TODO : Missing description : please, update your UML model asap.
     * 
     * ( Multiplicity : 1 )
     */

    @javax.persistence.ManyToOne(optional = false, fetch = javax.persistence.FetchType.LAZY, cascade = {
            javax.persistence.CascadeType.PERSIST, javax.persistence.CascadeType.MERGE,
            javax.persistence.CascadeType.REFRESH }) @javax.persistence.JoinColumn(name = "submitterId", referencedColumnName = "id", nullable = false)

    private User submitter = null;
    /**
     * "lazy" version of the submitter reference. Used by XML (un)marshallers to resolve possibly inderectly referenced
     * resource User.
     */

    @javax.persistence.Transient

    protected Reference p_submitter = null;

    /**
     * Creates a new Job.
     */
    protected Job() {
        super();
    }

    /**
     * Creates a new Job for the given Container Entity.
     *
     * The Parent Container CAN NOT BE NULL
     *
     * @param pContainer the parent container CAN NOT BE NULL
     */
    public Job(final TransientObjectManager pContainer) {
        super(pContainer);
    }

    /**
     * Returns submitTime Attribute
     * 
     * @return submitTime Attribute
     */
    public Date getSubmitTime() {
        return this.submitTime;
    }

    /**
     * Defines submitTime Attribute
     * 
     * @param pSubmitTime value to set
     */
    public void setSubmitTime(final Date pSubmitTime) {
        this.submitTime = pSubmitTime;
    }

    /**
     * Returns expectedTime Attribute
     * 
     * @return expectedTime Attribute
     */
    public String getExpectedTime() {
        return this.expectedTime;
    }

    /**
     * Defines expectedTime Attribute
     * 
     * @param pExpectedTime value to set
     */
    public void setExpectedTime(final String pExpectedTime) {
        this.expectedTime = pExpectedTime;
    }

    /**
     * Returns status Attribute
     * 
     * @return status Attribute
     */
    public Integer getStatus() {
        return this.status;
    }

    /**
     * Defines status Attribute
     * 
     * @param pStatus value to set
     */
    public void setStatus(final Integer pStatus) {
        this.status = pStatus;
    }

    /**
     * Returns excutorDID Attribute
     * 
     * @return excutorDID Attribute
     */
    public String getExcutorDID() {
        return this.excutorDID;
    }

    /**
     * Defines excutorDID Attribute
     * 
     * @param pExcutorDID value to set
     */
    public void setExcutorDID(final String pExcutorDID) {
        this.excutorDID = pExcutorDID;
    }

    /**
     * Returns submitterDID Attribute
     * 
     * @return submitterDID Attribute
     */
    public String getSubmitterDID() {
        return this.submitterDID;
    }

    /**
     * Defines submitterDID Attribute
     * 
     * @param pSubmitterDID value to set
     */
    public void setSubmitterDID(final String pSubmitterDID) {
        this.submitterDID = pSubmitterDID;
    }

    /**
     * Returns startedTime Attribute
     * 
     * @return startedTime Attribute
     */
    public Date getStartedTime() {
        return this.startedTime;
    }

    /**
     * Defines startedTime Attribute
     * 
     * @param pStartedTime value to set
     */
    public void setStartedTime(final Date pStartedTime) {
        this.startedTime = pStartedTime;
    }

    /**
     * Returns finishedTime Attribute
     * 
     * @return finishedTime Attribute
     */
    public Date getFinishedTime() {
        return this.finishedTime;
    }

    /**
     * Defines finishedTime Attribute
     * 
     * @param pFinishedTime value to set
     */
    public void setFinishedTime(final Date pFinishedTime) {
        this.finishedTime = pFinishedTime;
    }

    /**
     * Returns duration Attribute
     * 
     * @return duration Attribute
     */
    public Double getDuration() {
        return this.duration;
    }

    /**
     * Defines duration Attribute
     * 
     * @param pDuration value to set
     */
    public void setDuration(final Double pDuration) {
        this.duration = pDuration;
    }

    /**
     * Returns resultsFolderURI Attribute
     * 
     * @return resultsFolderURI Attribute
     */
    public String getResultsFolderURI() {
        return this.resultsFolderURI;
    }

    /**
     * Defines resultsFolderURI Attribute
     * 
     * @param pResultsFolderURI value to set
     */
    public void setResultsFolderURI(final String pResultsFolderURI) {
        this.resultsFolderURI = pResultsFolderURI;
    }

    /**
     * Returns timeout Attribute
     * 
     * @return timeout Attribute
     */
    public Long getTimeout() {
        return this.timeout;
    }

    /**
     * Defines timeout Attribute
     * 
     * @param pTimeout value to set
     */
    public void setTimeout(final Long pTimeout) {
        this.timeout = pTimeout;
    }

    /**
     * Returns message Collection
     * 
     * @return message Collection
     */
    public List<JobMessage> getMessage() {
        return this.message;
    }

    /**
     * Defines message Collection
     * 
     * @param pMessage collection to set
     */
    public void setMessage(final List<JobMessage> pMessage) {
        this.message = pMessage;
    }

    /**
     * Add a JobMessage to the collection
     * 
     * @param pJobMessage JobMessage to add
     */
    public void addMessage(final JobMessage pJobMessage) {
        if (this.message == null) {
            this.message = new ArrayList<JobMessage>();
        }

        this.message.add(pJobMessage);
    }

    /**
     * Returns userVolume Collection
     * 
     * @return userVolume Collection
     */
    public List<RequiredUserVolume> getUserVolume() {
        return this.userVolume;
    }

    /**
     * Defines userVolume Collection
     * 
     * @param pUserVolume collection to set
     */
    public void setUserVolume(final List<RequiredUserVolume> pUserVolume) {
        this.userVolume = pUserVolume;
    }

    /**
     * Add a RequiredUserVolume to the collection
     * 
     * @param pRequiredUserVolume RequiredUserVolume to add
     */
    public void addUserVolume(final RequiredUserVolume pRequiredUserVolume) {
        if (this.userVolume == null) {
            this.userVolume = new ArrayList<RequiredUserVolume>();
        }

        this.userVolume.add(pRequiredUserVolume);
    }

    /**
     * Returns runBy Reference If the runBy variable is null but its "lazy" version p_runBy is not, that lazy reference
     * will be resolved to the actual object.
     * 
     * @return runBy Reference
     */
    public COMPM getRunBy() {

        if (this.runBy == null && this.p_runBy != null) {
            this.runBy = (COMPM) resolve(this.p_runBy, COMPM.class);
        }
        return this.runBy;

    }

    /**
     * Defines runBy Reference
     * 
     * @param pRunBy reference to set
     */
    public void setRunBy(final COMPM pRunBy) {

        this.runBy = pRunBy;

    }

    /**
     * Returns computeDomain Reference If the computeDomain variable is null but its "lazy" version p_computeDomain is
     * not, that lazy reference will be resolved to the actual object.
     * 
     * @return computeDomain Reference
     */
    public ComputeDomain getComputeDomain() {

        if (this.computeDomain == null && this.p_computeDomain != null) {
            this.computeDomain = (ComputeDomain) resolve(this.p_computeDomain, ComputeDomain.class);
        }
        return this.computeDomain;

    }

    /**
     * Defines computeDomain Reference
     * 
     * @param pComputeDomain reference to set
     */
    public void setComputeDomain(final ComputeDomain pComputeDomain) {

        this.computeDomain = pComputeDomain;

    }

    /**
     * Returns submitter Reference If the submitter variable is null but its "lazy" version p_submitter is not, that
     * lazy reference will be resolved to the actual object.
     * 
     * @return submitter Reference
     */
    public User getSubmitter() {

        if (this.submitter == null && this.p_submitter != null) {
            this.submitter = (User) resolve(this.p_submitter, User.class);
        }
        return this.submitter;

    }

    /**
     * Defines submitter Reference
     * 
     * @param pSubmitter reference to set
     */
    public void setSubmitter(final User pSubmitter) {

        this.submitter = pSubmitter;

    }

    /**
     * Returns Jpa version for optimistic locking.
     * 
     * @return jpa version number
     */
    protected int getJpaVersion() {
        return this.jpaVersion;
    }

    /**
     * Returns Class type (discriminator value) in inheritance hierarchy.
     * 
     * @return class type
     */
    protected String getClassType() {
        return this.classType;
    }

    /**
     * Returns equals from id attribute here. Child classes can override this method to allow deep equals with
     * attributes / references / collections
     *
     * @param object the reference object with which to compare.
     * @param isDeep true means to call hashCode(sb, true) for all attributes / references / collections which are
     * MetadataElement implementations
     *
     * @return <code>true</code> if this object is the same as the obj argument; <code>false</code> otherwise.
     */
    @Override
    public boolean equals(final Object object, final boolean isDeep) {
        /* identity, nullable, class and identifiers checks */
        if (!(super.equals(object, isDeep))) {
            return false;
        }

        /* do check values (attributes / references / collections) */

        if (isDeep) {

            final Job other = (Job) object;

            if (!areEquals(this.submitTime, other.submitTime)) {
                return false;
            }

            if (!areEquals(this.expectedTime, other.expectedTime)) {
                return false;
            }

            if (!areEquals(this.status, other.status)) {
                return false;
            }

            if (!areEquals(this.excutorDID, other.excutorDID)) {
                return false;
            }

            if (!areEquals(this.submitterDID, other.submitterDID)) {
                return false;
            }

            if (!areEquals(this.startedTime, other.startedTime)) {
                return false;
            }

            if (!areEquals(this.finishedTime, other.finishedTime)) {
                return false;
            }

            if (!areEquals(this.duration, other.duration)) {
                return false;
            }

            if (!areEquals(this.resultsFolderURI, other.resultsFolderURI)) {
                return false;
            }

            if (!areEquals(this.timeout, other.timeout)) {
                return false;
            }

        }

        return true;
    }

    /**
     * Returns the property value given the property name. Can be any property (internal, attribute, reference,
     * collection) and all type must be supported (dataType, objectType, enumeration)
     *
     * @param propertyName name of the property (like in UML model)
     *
     * @return property value or null if unknown or not defined
     */
    @Override
    public Object getProperty(final String propertyName) {
        // first : checks if propertyName is null or empty :
        if (propertyName == null) {
            return null;
        }
        // second : search in parent classes (maybe null) :
        Object res = super.getProperty(propertyName);

        if ("submitTime".equals(propertyName)) {
            return getSubmitTime();
        }

        if ("expectedTime".equals(propertyName)) {
            return getExpectedTime();
        }

        if ("status".equals(propertyName)) {
            return getStatus();
        }

        if ("excutorDID".equals(propertyName)) {
            return getExcutorDID();
        }

        if ("submitterDID".equals(propertyName)) {
            return getSubmitterDID();
        }

        if ("startedTime".equals(propertyName)) {
            return getStartedTime();
        }

        if ("finishedTime".equals(propertyName)) {
            return getFinishedTime();
        }

        if ("duration".equals(propertyName)) {
            return getDuration();
        }

        if ("resultsFolderURI".equals(propertyName)) {
            return getResultsFolderURI();
        }

        if ("timeout".equals(propertyName)) {
            return getTimeout();
        }

        if ("message".equals(propertyName)) {
            return getMessage();
        }

        if ("userVolume".equals(propertyName)) {
            return getUserVolume();
        }

        if ("runBy".equals(propertyName)) {
            return getRunBy();
        }

        if ("computeDomain".equals(propertyName)) {
            return getComputeDomain();
        }

        if ("submitter".equals(propertyName)) {
            return getSubmitter();
        }

        return res;
    }

    /**
     * Sets the property value to the given property name. Can be any property (internal, attribute, reference,
     * collection) and all type must be supported (dataType, objectType, enumeration)
     *
     * @param propertyName name of the property (like in UML model)
     *
     * @param pValue to be set
     * 
     * @return true if property has been set
     */
    @Override
    public boolean setProperty(final String propertyName, final Object pValue) {
        // first : checks if propertyName is null or empty :
        if (propertyName == null) {
            return false;
        }
        // second : search in parent classes (maybe null) :
        boolean res = super.setProperty(propertyName, pValue);

        if (!res) {

            if ("submitTime".equals(propertyName)) {
                setSubmitTime((Date) pValue);
                return true;
            }

            if ("expectedTime".equals(propertyName)) {
                setExpectedTime((String) pValue);
                return true;
            }

            if ("status".equals(propertyName)) {
                setStatus((Integer) pValue);
                return true;
            }

            if ("excutorDID".equals(propertyName)) {
                setExcutorDID((String) pValue);
                return true;
            }

            if ("submitterDID".equals(propertyName)) {
                setSubmitterDID((String) pValue);
                return true;
            }

            if ("startedTime".equals(propertyName)) {
                setStartedTime((Date) pValue);
                return true;
            }

            if ("finishedTime".equals(propertyName)) {
                setFinishedTime((Date) pValue);
                return true;
            }

            if ("duration".equals(propertyName)) {
                setDuration((Double) pValue);
                return true;
            }

            if ("resultsFolderURI".equals(propertyName)) {
                setResultsFolderURI((String) pValue);
                return true;
            }

            if ("timeout".equals(propertyName)) {
                setTimeout((Long) pValue);
                return true;
            }

            if ("runBy".equals(propertyName)) {
                setRunBy((COMPM) pValue);
                return true;
            }

            if ("computeDomain".equals(propertyName)) {
                setComputeDomain((ComputeDomain) pValue);
                return true;
            }

            if ("submitter".equals(propertyName)) {
                setSubmitter((User) pValue);
                return true;
            }

        }

        return res;
    }

    /**
     * Sets all Reference fields to their appropriate value.<br/>
     */
    @Override
    protected void prepareReferencesForMarshalling() {
        super.prepareReferencesForMarshalling();

        if (getRunBy() != null) {
            this.p_runBy = getRunBy().asReference();
            if (getStateFor(getRunBy()).isToBeMarshalled()) {
                getRunBy().setXmlId();
            }
        }

        if (getComputeDomain() != null) {
            this.p_computeDomain = getComputeDomain().asReference();
            if (getStateFor(getComputeDomain()).isToBeMarshalled()) {
                getComputeDomain().setXmlId();
            }
        }

        if (getSubmitter() != null) {
            this.p_submitter = getSubmitter().asReference();
            if (getStateFor(getSubmitter()).isToBeMarshalled()) {
                getSubmitter().setXmlId();
            }
        }

    }

    /**
     * Resets all Reference fields to null.<br/>
     */
    @Override
    protected void resetReferencesAfterMarshalling() {
        super.prepareReferencesForMarshalling();

        this.p_runBy = null;

        this.p_computeDomain = null;

        this.p_submitter = null;

    }

    /**
     * Puts the string representation in the given string buffer : <br>
     * "Type =[class name @ hashcode] : { field name = field value , ...}"
     *
     * @param sb given string buffer to fill
     * @param isDeep true means to call deepToString(sb, true, ids) for all attributes / references / collections which
     * are MetadataElement implementations
     * @param ids identity map to avoid cyclic loops
     *
     * @return stringbuffer the given string buffer filled with the string representation
     */
    @Override
    protected StringBuilder deepToString(final StringBuilder sb, final boolean isDeep,
            final Map<MetadataElement, Object> ids) {

        sb.append("\n[ Job");
        sb.append("={");

        sb.append("submitTime=");
        if (getSubmitTime() != null) {
            MetadataElement.deepToString(sb, isDeep, ids, getSubmitTime());
        }
        sb.append(", ");
        sb.append("expectedTime=");
        if (getExpectedTime() != null) {
            MetadataElement.deepToString(sb, isDeep, ids, getExpectedTime());
        }
        sb.append(", ");
        sb.append("status=");
        if (getStatus() != null) {
            MetadataElement.deepToString(sb, isDeep, ids, getStatus());
        }
        sb.append(", ");
        sb.append("excutorDID=");
        if (getExcutorDID() != null) {
            MetadataElement.deepToString(sb, isDeep, ids, getExcutorDID());
        }
        sb.append(", ");
        sb.append("submitterDID=");
        if (getSubmitterDID() != null) {
            MetadataElement.deepToString(sb, isDeep, ids, getSubmitterDID());
        }
        sb.append(", ");
        sb.append("startedTime=");
        if (getStartedTime() != null) {
            MetadataElement.deepToString(sb, isDeep, ids, getStartedTime());
        }
        sb.append(", ");
        sb.append("finishedTime=");
        if (getFinishedTime() != null) {
            MetadataElement.deepToString(sb, isDeep, ids, getFinishedTime());
        }
        sb.append(", ");
        sb.append("duration=");
        if (getDuration() != null) {
            MetadataElement.deepToString(sb, isDeep, ids, getDuration());
        }
        sb.append(", ");
        sb.append("resultsFolderURI=");
        if (getResultsFolderURI() != null) {
            MetadataElement.deepToString(sb, isDeep, ids, getResultsFolderURI());
        }
        sb.append(", ");
        sb.append("timeout=");
        if (getTimeout() != null) {
            MetadataElement.deepToString(sb, isDeep, ids, getTimeout());
        }
        sb.append(", ");
        sb.append("message=");
        if (getMessage() != null) {
            MetadataElement.deepToString(sb, isDeep, ids, getMessage());
        }
        sb.append(", ");
        sb.append("userVolume=");
        if (getUserVolume() != null) {
            MetadataElement.deepToString(sb, isDeep, ids, getUserVolume());
        }
        sb.append(", ");
        sb.append("runBy.id=");
        if (getRunBy() != null) {
            getRunBy().getId();
        }
        sb.append(", ");
        sb.append("computeDomain.id=");
        if (getComputeDomain() != null) {
            getComputeDomain().getId();
        }
        sb.append(", ");
        sb.append("submitter.id=");
        if (getSubmitter() != null) {
            getSubmitter().getId();
        }

        return sb.append("} ]");

    }

    public boolean isValid() {
        if (!super.isValid())
            return false;
        boolean isOk = true;
        isOk = isOk && submitTime != null;
        isOk = isOk && status != null;
        isOk = isOk && (computeDomain != null || p_computeDomain != null);
        isOk = isOk && (submitter != null || p_submitter != null);
        return isOk;
    }

    public String validationErrors() {
        StringBuffer sb = new StringBuffer(super.validationErrors());

        if (submitTime == null)
            sb.append("- atribute 'submitTime' cannot be null\n");

        if (status == null)
            sb.append("- atribute 'status' cannot be null\n");

        if (computeDomain == null && p_computeDomain == null)
            sb.append("- reference 'computeDomain' cannot be null\n");

        if (submitter == null && p_submitter == null)
            sb.append("- reference 'submitter' cannot be null\n");

        return sb.toString();
    }

}
